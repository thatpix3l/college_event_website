// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package gen_sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBaseEvent = `-- name: CreateBaseEvent :one
INSERT INTO BaseEvent (
        title,
        about,
        university,
        start_time,
        contact_phone,
        contact_email,
        event_type,
        latitude,
        longitude
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, title, about, university, start_time, contact_phone, contact_email, event_type, latitude, longitude
`

type CreateBaseEventParams struct {
	Title        string           `schema:",required"`
	About        string           `schema:",required"`
	University   string           `schema:",required"`
	StartTime    pgtype.Timestamp `schema:",required"`
	ContactPhone string           `schema:",required"`
	ContactEmail string           `schema:",required"`
	EventType    string           `schema:",required"`
	Latitude     float64          `schema:",required"`
	Longitude    float64          `schema:",required"`
}

func (q *Queries) CreateBaseEvent(ctx context.Context, arg CreateBaseEventParams) (Baseevent, error) {
	row := q.db.QueryRow(ctx, createBaseEvent,
		arg.Title,
		arg.About,
		arg.University,
		arg.StartTime,
		arg.ContactPhone,
		arg.ContactEmail,
		arg.EventType,
		arg.Latitude,
		arg.Longitude,
	)
	var i Baseevent
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.About,
		&i.University,
		&i.StartTime,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.EventType,
		&i.Latitude,
		&i.Longitude,
	)
	return i, err
}

const createBaseUser = `-- name: CreateBaseUser :one
INSERT INTO BaseUser(
        name_first,
        name_last,
        email,
        password_hash,
        is_super_admin,
        university
    )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name_first, name_last, email, password_hash, is_super_admin, university
`

type CreateBaseUserParams struct {
	NameFirst    string      `schema:",required"`
	NameLast     string      `schema:",required"`
	Email        string      `schema:",required"`
	PasswordHash string      `schema:",required"`
	IsSuperAdmin bool        `schema:",required"`
	University   pgtype.Text `schema:",required"`
}

func (q *Queries) CreateBaseUser(ctx context.Context, arg CreateBaseUserParams) (Baseuser, error) {
	row := q.db.QueryRow(ctx, createBaseUser,
		arg.NameFirst,
		arg.NameLast,
		arg.Email,
		arg.PasswordHash,
		arg.IsSuperAdmin,
		arg.University,
	)
	var i Baseuser
	err := row.Scan(
		&i.ID,
		&i.NameFirst,
		&i.NameLast,
		&i.Email,
		&i.PasswordHash,
		&i.IsSuperAdmin,
		&i.University,
	)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO Comment (body, posted_by, base_event)
VALUES ($1, $2, $3)
RETURNING id, body, posted_by, base_event
`

type CreateCommentParams struct {
	Body      string      `schema:",required"`
	PostedBy  pgtype.Text `schema:",required"`
	BaseEvent string      `schema:",required"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Body, arg.PostedBy, arg.BaseEvent)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.PostedBy,
		&i.BaseEvent,
	)
	return i, err
}

const createRating = `-- name: CreateRating :one
INSERT INTO Rating (stars, posted_by, base_event)
VALUES ($1, $2, $3)
RETURNING id, stars, posted_by, base_event
`

type CreateRatingParams struct {
	Stars     int32       `schema:",required"`
	PostedBy  pgtype.Text `schema:",required"`
	BaseEvent string      `schema:",required"`
}

func (q *Queries) CreateRating(ctx context.Context, arg CreateRatingParams) (Rating, error) {
	row := q.db.QueryRow(ctx, createRating, arg.Stars, arg.PostedBy, arg.BaseEvent)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.Stars,
		&i.PostedBy,
		&i.BaseEvent,
	)
	return i, err
}

const createRso = `-- name: CreateRso :one
INSERT INTO Rso (title, about, university)
VALUES ($1, $2, $3)
RETURNING id, title, about, university
`

type CreateRsoParams struct {
	Title      string `schema:",required"`
	About      string `schema:",required"`
	University string `schema:",required"`
}

func (q *Queries) CreateRso(ctx context.Context, arg CreateRsoParams) (Rso, error) {
	row := q.db.QueryRow(ctx, createRso, arg.Title, arg.About, arg.University)
	var i Rso
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.About,
		&i.University,
	)
	return i, err
}

const createRsoMember = `-- name: CreateRsoMember :one
INSERT INTO RsoMember (id, rso)
VALUES ($1, $2)
RETURNING id, rso, is_admin
`

type CreateRsoMemberParams struct {
	ID  string `schema:",required"`
	Rso string `schema:",required"`
}

func (q *Queries) CreateRsoMember(ctx context.Context, arg CreateRsoMemberParams) (Rsomember, error) {
	row := q.db.QueryRow(ctx, createRsoMember, arg.ID, arg.Rso)
	var i Rsomember
	err := row.Scan(&i.ID, &i.Rso, &i.IsAdmin)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO Tag (title)
VALUES ($1)
RETURNING id, title
`

func (q *Queries) CreateTag(ctx context.Context, title string) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, title)
	var i Tag
	err := row.Scan(&i.ID, &i.Title)
	return i, err
}

const createTaggedEvent = `-- name: CreateTaggedEvent :one
INSERT INTO TaggedEvent (tag, base_event)
VALUES ($1, $2)
RETURNING tag, base_event
`

type CreateTaggedEventParams struct {
	Tag       string `schema:",required"`
	BaseEvent string `schema:",required"`
}

func (q *Queries) CreateTaggedEvent(ctx context.Context, arg CreateTaggedEventParams) (Taggedevent, error) {
	row := q.db.QueryRow(ctx, createTaggedEvent, arg.Tag, arg.BaseEvent)
	var i Taggedevent
	err := row.Scan(&i.Tag, &i.BaseEvent)
	return i, err
}

const createTaggedRso = `-- name: CreateTaggedRso :one
INSERT INTO TaggedRso (tag, rso)
VALUES ($1, $2)
RETURNING tag, rso
`

type CreateTaggedRsoParams struct {
	Tag string `schema:",required"`
	Rso string `schema:",required"`
}

func (q *Queries) CreateTaggedRso(ctx context.Context, arg CreateTaggedRsoParams) (Taggedrso, error) {
	row := q.db.QueryRow(ctx, createTaggedRso, arg.Tag, arg.Rso)
	var i Taggedrso
	err := row.Scan(&i.Tag, &i.Rso)
	return i, err
}

const createUniversity = `-- name: CreateUniversity :one
INSERT INTO University (title, about, latitude, longitude)
VALUES ($1, $2, $3, $4)
RETURNING id, title, latitude, longitude, about
`

type CreateUniversityParams struct {
	Title     string  `schema:",required"`
	About     string  `schema:",required"`
	Latitude  float64 `schema:",required"`
	Longitude float64 `schema:",required"`
}

func (q *Queries) CreateUniversity(ctx context.Context, arg CreateUniversityParams) (University, error) {
	row := q.db.QueryRow(ctx, createUniversity,
		arg.Title,
		arg.About,
		arg.Latitude,
		arg.Longitude,
	)
	var i University
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Latitude,
		&i.Longitude,
		&i.About,
	)
	return i, err
}

const readBaseUsers = `-- name: ReadBaseUsers :many
WITH uni AS (
    SELECT id AS university_id,
        title AS university_title,
        latitude AS university_latitude,
        longitude AS university_longitude,
        about AS university_about
    FROM University
)
SELECT id, name_first, name_last, email, password_hash, is_super_admin, university, university_id, university_title, university_latitude, university_longitude, university_about
FROM BaseUser
    LEFT JOIN uni ON BaseUser.university = uni.university_id
`

type ReadBaseUsersRow struct {
	ID                  string        `schema:",required"`
	NameFirst           string        `schema:",required"`
	NameLast            string        `schema:",required"`
	Email               string        `schema:",required"`
	PasswordHash        string        `schema:",required"`
	IsSuperAdmin        bool          `schema:",required"`
	University          pgtype.Text   `schema:",required"`
	UniversityID        pgtype.Text   `schema:",required"`
	UniversityTitle     pgtype.Text   `schema:",required"`
	UniversityLatitude  pgtype.Float8 `schema:",required"`
	UniversityLongitude pgtype.Float8 `schema:",required"`
	UniversityAbout     pgtype.Text   `schema:",required"`
}

func (q *Queries) ReadBaseUsers(ctx context.Context) ([]ReadBaseUsersRow, error) {
	rows, err := q.db.Query(ctx, readBaseUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadBaseUsersRow
	for rows.Next() {
		var i ReadBaseUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.NameFirst,
			&i.NameLast,
			&i.Email,
			&i.PasswordHash,
			&i.IsSuperAdmin,
			&i.University,
			&i.UniversityID,
			&i.UniversityTitle,
			&i.UniversityLatitude,
			&i.UniversityLongitude,
			&i.UniversityAbout,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readEvents = `-- name: ReadEvents :many
SELECT id, title, about, university, start_time, contact_phone, contact_email, event_type, latitude, longitude
FROM BaseEvent
`

func (q *Queries) ReadEvents(ctx context.Context) ([]Baseevent, error) {
	rows, err := q.db.Query(ctx, readEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Baseevent
	for rows.Next() {
		var i Baseevent
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.About,
			&i.University,
			&i.StartTime,
			&i.ContactPhone,
			&i.ContactEmail,
			&i.EventType,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readUniversities = `-- name: ReadUniversities :many
SELECT id, title, latitude, longitude, about
FROM University
`

func (q *Queries) ReadUniversities(ctx context.Context) ([]University, error) {
	rows, err := q.db.Query(ctx, readUniversities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []University
	for rows.Next() {
		var i University
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Latitude,
			&i.Longitude,
			&i.About,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
